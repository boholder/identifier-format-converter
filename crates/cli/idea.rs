/// 我想象中的成品：
/// naming
///
/// TODO README里写一些复杂的example和命令行组合使用用例。
///
/// --------------------------
///
/// 行为：
/// 对输入字符流中所有识别为有效可转换的字符串都做转换。
/// TODO 对抽取出的结果做distinct，因为可能一个标识符多次出现。
/// 每个匹配生成一行结果。
/// TODO 如果输入中存在转换失败，中止，不输出stdin，返回状态非0，输出错误信息。去掉strict
///
/// 如果我想只抽取标识符：
/// 类型 目标=赋值，
/// 函数（目标，目标）
/// 标识符：
/// 前面可能是空白符，前括号，逗号。
/// 后面可能是空白符，等号，逗号，后括号。
/// 靠这个识别提取标识符
///
/// TODO 给每个主流语言找一段试试吧，有些语言没括号。
///
/// 没有输入（且不在交互式界面），没有输出，返回状态非0。
/// 有输入，但没匹配到输出，返回状态非0。
///
/// > naming camelCase
/// > camelCase CAMEL_CASE camel_case camel-case camelCase CamelCase
/// 每行结果首先输出匹配到的输入，再按顺序输出转换后的词，以空格做分离。
///
/// TODO - 作为stdin的同义词。（这个工具没有stdout的事）
/// 比如 curl www...tar.gz | tar xvf - ，代表把输入当作文件看待。
///
/// TODO -f --filter <格式>（-f"Sskcp"）
/// 在能识别成有效字符串的前提下，只处理指定格式的字符串
///
/// screaming-snake, snake, kebab, camel, pascal, hungarian-notation
/// S, s, k, c, p, h
///
/// TODO -o --output <格式> 输出指定的变换格式，默认输出所有5种格式
///
/// TODO -e --eof <flag> 学xargs，读到终止符应该停止。
///
/// TODO --regex （输出样式变更）输出这些格式合在一起的OR形式正则表达式。
///
/// TODO --json （输出样式变更）输出json格式的结构化信息
/// {"origin":"...","regex":"OR组成的正则"，"screaming_snake":"..."}
///
/// 一次调用命令只能建立一种转换映射：
/// A,B格式的字符串，转换成C格式。